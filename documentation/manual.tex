\documentclass{article}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{bookman}
\usepackage{color}
\usepackage{graphics}

\newcommand{\sca}{{\em labCA}}
\newcommand{\scilab}{{\em scilab}}
\newcommand{\matlab}{{\em matlab}}
\newcommand{\windoze}{{\em win32}}
\newcommand{\ezca}{{\em ezca}}
\newcommand{\com}[1]{{\tt #1}}
\newcommand{\NAN}{\mbox{NaN}}

\newcommand{\PVITEM}{
\item[pvs] Column vector (in matlab: $m\times 1$ cell matrix)
of $m$ strings.
}

\title{\sca{} --- An EPICS Channel Access Interface for \scilab{} and \matlab{}}
\author{Till Straumann <strauman@slac.stanford.edu>, 2003}
\date{\$Id: manual.tex,v 1.3 2003/12/24 19:57:08 till Exp \$}


\begin{document}
\maketitle
\section{Introduction}
The \sca{} package provides an interface to the
EPICS channel access client library which can be
integrated with the \scilab{} or \matlab{} applications.
Both, \scilab{} and \matlab{} feature an API for interfacing
to user binaries written in a programming language such
as C or Fortran. \sca{} properly wraps the essential
channel access routines and makes them accessible
from the \scilab%
\footnote{throughout this text, references to \scilab{}
usually mean \scilab{} or \matlab.}
command line.

\sca{} actually uses an extra layer, the \ezca{} library
which transparently manages and caches channel access 
connections. A modified version of \ezca{} comes with
\sca, adding thread-safety and hence EPICS 3.14 fitness.

A very convenient feature of \sca{} is the ability
to execute \ezca{} calls on groups of PVs, simply by
passing the respective \sca{} routine a column vector
of PV names.

\sca{} has been tested with EPICS 3.13, 3.14, \scilab-2.7,
\matlab-6.5, \matlab-7 on {\em linux}, {\em solaris} and
\windoze.

\section{Supported EZCA Calls}
\sca{} implements an interface to almost all public
\ezca{} routines\footnote{%
the \matlab{} implementation may still lack some of the
more esoteric commands}. Note that the arguments and
return values do not exactly correspond to the respective
\ezca{} originals but have been adapted to make sense
in the  \scilab{} environment.

\subsection{Common Arguments and Return Values}
\subsubsection{PV Argument}
All \sca{} calls take a {\em PV} argument identifying
the EPICS process variables the user wants to connect to.
PVs are plain ASCII strings. \sca{} is capable of handling
multiple PVs in a single call; they are simply passed as a
column vector:
\begin{verbatim}
pvs = [ 'PVa'; 'b'; 'anotherone']
\end{verbatim}
Because \matlab{} doesn't allow the rows of
a string vector to be of different size, the \matlab{}
wrapper expects a {\em cell} array of strings:
\begin{verbatim}
pvs = { 'PVa'; 'b'; 'anotherone'}
\end{verbatim}

All channel access activities for the PVs
passed to a single \sca{} call are batched together and
completion of the batch is awaited before returning from
the \sca{} call. Consider the following example:%
\footnote{
In \matlab{}, the square brackets (``[]'') must be replaced
by curly braces (``\{\}'').}
\begin{verbatim}
ezcaPut( 'trigger', 1 ) \\
data=ezcaGet( ['sensor1' ; 'sens2'] );
\end{verbatim}
\begin{itemize}
%
\item It is guaranteed that writing the ``trigger''
completes (on the CA server) prior to reading the
sensors.%%
\footnote{If the remote sensors have finite
processing time, the subsequent CA read may still
get old data --- depending on the device support
etc.; this is beyond the scope of channel access, however.}
%
\item Reading the two sensors is done in ``parallel'' ---
the exact order is unspecified. After the command sequence
(successfully) completes, all the data are valid.
\end{itemize}

\subsubsection{Timestamp Format}
\label{tsformat}
Channel access timestamps are ``POSIX struct timespec''
compliant, i.e. they provide the number of nanoseconds
expired since 00:00:00 UTC, January 1, 1970. \sca{} 
translates the timestamps into {\em complex numbers}
with the seconds ({\tt tv\_sec} member) and nanoseconds
({\tt tv\_nsec}) in the real and imaginary parts, respectively.
This makes it easy to extract the seconds while still maintaining
full accuracy.

\subsection{List of all Supported Calls}
\subsubsection{ezcaGet}
\label{ezcaget}
\begin{verbatim}
[value, timestamp] = ezcaGet(pvs, nmax, type)}
\end{verbatim}
Read a number of $m$ PVs, which may be scalars or arrays of
different dimensions. The result is converted into a $m\times n$
matrix. The number of columns, $n$, is automatically assigned
to fit the largest array among the $m$ PVs. All values are
converted into double precision numbers. PVs with less than
$n$ elements have their excess elements in the result matrix
filled with \NAN.
\begin{description}
\PVITEM
%
%
\item[nmax] ({\em optional argument}) Maximum number of elements
(per PV) to retrieve (i.e. limit the number of columns of \com{value} to
{\em nmax}).
If set to 0 (default), all elements are fetched
and the number of columns, $n$, in the result matrix is set to the
maximum number of elements among all submitted PVs. This is useful
to limit the transfer time of very large waveforms (unfortunately,
CA is not capable to return only the valid elements (``NORD'') of
an array --- it will always ship {\em all} elements).
%
%
\item[type] ({\em optional argument}) A string describing the
data type to be used for the channel access data transfer. Note
that \sca{} always converts the data to ``double'' locally. It
can be desirable, however, to use a different data type for the
transfer because by default CA transfers are limited to $\approx 16$kB.
Legal values for \com{type}{} are \com{byte}, \com{short}, \com{long},
\com{float}, \com{double} or \com{native}. There should rarely
be a need for using anything other than \com{native}, the default,
which directs CA to use the same type for transfer as the data are
stored on the server.

On \matlab{}{}, however, the type \com{char}{} is also allowed which
results in \com{ezcaGet()}{} behaving like \com{ezcaGetString()}{}
(see \ref{getstring} below).

Note that while \com{native}{} might result in different types
being used for different PVs, it is currently not possible to
explicitely request different types for different PVs (i.e. the
\com{type}{} argument currently cannot be a column vector).
%
%
\item[value] The $m\times n$ result matrix. $n$ is automatically
assigned to accomodate the PV with most elements. If the \com{nmax}{}
argument is given and is nonzero but less than the automatically
determined $n$, then $n$ is clipped to \com{nmax}.

Excess elements of PVs with less than $n$ elements are filled with
\NAN{} values.

\sca{} checks the channel access severity of the retrieved PVs and
fills the rows of {\em INVALID} PVs with \NAN%
\footnote{
Actually, all fields of an EPICS database record share a common
severity, (which itself is a field/PV --- the .SEVR field). However,
the {\em INVALID} status actually only applies to the .VAL field
of a record --- other fields (e.g. .EGU) may still hold meaningful data.
Consequently, {\em INVALID} PVs are returned as \NAN{} only if
they refer to a record's .VAL field.
}. In addition, warning
messages are printed to the console if a PV's alarm status exceeds
a configurable threshold (see \ref{swarnlevel}).
%
%
\item[timestamp] ({\em optional return value}) Returns a $m\times 1$
column vector of {\em complex} numbers holding the CA timestamps of
the requested PVs. The timestamps count the number of seconds (real part)
and fractional nanoseconds (imaginary part) elapsed since
00:00:00 UTC, January 1, 1970.
\end{description}

\subsubsection{ezcaGetString}
\label{getstring}
Retrieve a number of PVs as strings, i.e. let the CA server convert
them to strings (if the PVs are not native strings already) and transfer
them. This is especially useful to read ``enum''-type PVs.

Note that the \matlab{} implementation lacks this command. It is implemented
by giving a \com{char}{} type argument to \com{ezcaGet}.
\begin{verbatim}
[value, timestamp] = ezcaGetString(pvs, nmax)
\end{verbatim}
\begin{description}
\PVITEM
%
%
\item[nmax] ({\em optional argument})
See \com{ezcaGet}{} (\ref{ezcaget}) for a description of this parameter.
\item[value] a $m\times n$ (\matlab: {\em cell}-) matrix of strings. See \com{ezcaGet}{}
(\ref{ezcaget}) for more information.
\item[timestamp] ({\em optional return value})
See \com{ezcaGet}{} (\ref{ezcaget}) for a description of this return value.
\end{description}

\subsubsection{ezcaPut}
\label{ezcaput}
Write to a number of PVs which may be scalars or arrays of different
dimensions. It is possible to write the same value to a number of PVs.
\begin{verbatim}
ezcaPut(pvs, value, type)
\end{verbatim}
\begin{description}
\PVITEM
%
%
\item[value] $m\times n$ matrix or $1\times n$ row vector of values
to be written to the PVs. If there is only a single row in \com{value}{}
it is written to all $m$ PVs.

It is possible to write less than $n$ elements --- \sca{} scans all rows
for \NAN{} values and only transfers up to the last non-\NAN{} element in each
row.
%
%
\item[type] ({\em optional argument}) A string describing the
data type to be used for the channel access data transfer. Note
that \sca{} always converts the data from ``double'' locally. It
can be desirable, however, to use a different data type for the
transfer because by default CA transfers are limited to $\approx 16$kB.
Legal values for \com{type}{} are \com{byte}, \com{short}, \com{long},
\com{float}, \com{double} or \com{native}. There should rarely
be a need for using anything other than \com{native}, the default,
which directs CA to use the same type for transfer as the data are
stored on the server.

On \matlab{}{}, however, the type \com{char}{} is also allowed which
results in \com{ezcaPut()}{} behaving like \com{ezcaPutString()}{}
(see \ref{putstring} below).

Note that while \com{native}{} might result in different types
being used for different PVs, it is currently not possible to
explicitely request different types for different PVs (i.e. the
\com{type}{} argument currently cannot be a column vector).
%
\end{description}

\subsubsection{ezcaPutString}
\label{putstring}
Write a number of PVs as strings, i.e. let the CA server convert
them to their native data type (if the PVs are not native strings already).
This is especially useful to write ``enum''-type PVs.

Note that the \matlab{} implementation lacks this command. It is implemented
by giving a \com{char}{} type argument to \com{ezcaPut}.
\begin{verbatim}
ezcaPutString(pvs, value)
\end{verbatim}
\begin{description}
\PVITEM
%
%
\item[value] a $m\times n$ (\matlab: {\em cell}-) matrix of strings. See \com{ezcaPut}{}
(\ref{ezcaput}) for more information.
\end{description}


\subsubsection{ezcaGetNelem}
\begin{verbatim}
numberOfElements = ezcaGetNelem(pvs)
\end{verbatim}
Retrieve the element count of a number of PVs. Note that this is not
necessarily the number of {\em valid} elements (e.g. the actual number
of values read from a device into a waveform) but the maximum number
of elements a PV can hold.
\begin{description}
\PVITEM
%%
\item[numberOfElements] $m\times 1$ column vector of the PV's number
of elements (``array dimension'').
\end{description}

\subsubsection{ezcaGetControlLimits}
\begin{verbatim}
[lowLimit, hiLimit] = ezcaGetControlLimits(pvs)
\end{verbatim}
Retrieve the control limits associated with a number of PVs.
\begin{description}
\PVITEM
%%
\item[lowLimit] $m\times 1$ column vector of the PV's low control limit.
\item[hiLimit]  $m\times 1$ column vector of the PV's high control limit.
\end{description}


\subsubsection{ezcaGetGraphicLimits}
\begin{verbatim}
[lowLimit, hiLimit] = ezcaGetGraphicLimits(pvs)
\end{verbatim}
Retrieve the graphic limits associated with a number of PVs.
\begin{description}
\PVITEM
%%
\item[lowLimit] $m\times 1$ column vector of the PV's low graphic limit.
\item[hiLimit]  $m\times 1$ column vector of the PV's high graphic limit.
\end{description}


\subsubsection{ezcaGetStatus}
\begin{verbatim}
[severity, status, timestamp]  = ezcaGetStatus(pvs)
\end{verbatim}
Retrieve the alarm severity and status of a number of PVs along
with their timestamp.
\begin{description}
\PVITEM
%%
\item[severity] $m\times 1$ column vector of the alarm severities.
\item[status] $m\times 1$ column vector of the alarm status.
\item[timestamp] $m\times 1$ {\em complex} column vector holding the
PV timestamps (see \ref{tsformat} about the timestamp format).
\end{description}


\subsubsection{ezcaGetPrecision}
\begin{verbatim}
precision = ezcaGetPrecision(pvs)
\end{verbatim}
Retrieve the precision of a number of PVs.
\begin{description}
\PVITEM
%%
\item[precisiom] $m\times 1$ column vector of the PV's precision.
\end{description}

\subsubsection{ezcaGetUnits}
\begin{verbatim}
units = ezcaGetUnits(pvs)
\end{verbatim}
Retrieve the engineering units of a number of PVs.
\begin{description}
\PVITEM
%%
\item[units] $m\times 1$ column vector (on \matlab: cell matrix)
of strings holding the PV EGUs.
\end{description}

\subsubsection{ezcaGetRetryCount, ezcaSetRetryCount}
\begin{verbatim}
currentRetryCount = ezcaGetRetryCount()
ezcaSetRetryCount(newRetryCount)
\end{verbatim}
Retrieve / set the \ezca{} library retryCount parameter (consult the \ezca{}
documentation for more information).


\subsubsection{ezcaGetTimeout, ezcaSetTimeout}
\begin{verbatim}
currentTimeout = ezcaGetTimeout()
ezcaSetTimeout(newTimeout)
\end{verbatim}
Retrieve / set the \ezca{} library timeout parameter (consult the \ezca{}
documentation for more information).

\subsubsection{ezcaDebugOn, ezcaDebugOff}
\begin{verbatim}
ezcaDebugOn()
ezcaDebugOff()
\end{verbatim}
Switch the \ezca{} library's debugging facility on and off, respectively.

\subsubsection{ezcaSetSeverityWarnLevel}
\label{swarnlevel}
\begin{verbatim}
ezcaSetSeverityWarnLevel(newlevel)
\end{verbatim}
Set the warning threshold for \com{ezcaGet()} operations.
A warning message is printed when retrieving a PV with a severity bigger
or equal to the warning level. Supported values are $0..3$ (No alarm,
minor alarm, major alarm, invalid alarm). The initial/default value is 3.

\section{Building and Using \sca{}}
\subsection{Build}
\sca{} comes with `{\tt config}' subdirectory and Makefiles conforming to the
EPICS build system. Following a configuration step which involves editing
two small files, '{\tt make} is executed which installs the generated libraries
and scripts.

Prior to invoking the \scilab{} or \matlab{} application, the system
must be properly set up in order for the applications to locate the
\sca{} and channel access libraries.

\subsubsection{Prerequisites}
\sca{} needs an EPICS BASE installation that was built {\em with shared
libraries}. The main reason being that \matlab's {\em mex} files cannot
have multiple entry points. Hence, when statically linking multiple {\em mex}
files against {\em ezca, ca, Com} etc. multiple copies of those libraries
would end up in the running \matlab{} application with possible adverse
effects. It should be possible to build and use the \scilab{} interface
with static libraries --- minor tweaks might be necessary.

\sca{} has been tested with \matlab-6.5, \matlab-7.0 and \scilab-2.7
under a variety of EPICS releases ranging from 3.13.2
to 3.14.4 on \windoze, {\em linux-x86}, {\em linux-ppc} and
{\em solaris-sparc-gnu}. 

\subsubsection{Configuration}
Two files, `{\tt config/CONFIG}' and `{\tt config/RELEASE}' need to
be adapted to the user's installation:
\begin{description}
\item[\tt CONFIG:] Setting the {\tt MAKEFOR} variable in this file
determines the target application program the interface library is
built for. Valid settings are {\tt MAKEFOR=SCILAB} or {\tt MAKEFOR=MATLAB}.
Any setting other than {\tt MATLAB} are treated like {\tt SCILAB}.
%
%
\item[\tt RELEASE:] In this file, paths to the EPICS base (`{\tt EPICS\_BASE}'
variable) and \scilab{} (`{\tt SCILABDIR}' variable) or \matlab{} (`{\tt MATLABDIR}'
variable) installations must be specified.

Under \windoze{}, an additional variable
`{\tt MATLIB\_SUBDIR}' must be set directing the build process to select the correct
{\tt libmx.lib} and {\tt libmex.lib} library variants. The setting of this variable
is compiler dependent.
\begin{description}
\item[\tt MATLABDIR=<path>] {\tt <path>} defining the \matlab{} installation
directory where the `{\tt extern}' subdirectory can be found (e.g.
{\tt /opt/matlabR14beta2}).
\item[\tt SCILABDIR=<path>] {\tt <path>} defining the \scilab{} installation
directory where the `{\tt routines}' subdirectory can be found (e.g.
{\tt /usr/lib/scilab-2.7}).
\item[\tt MATLIB\_SUBDIR=<pathelem>] {\tt <pathelem>} chosing the subdirectory
corresponding to the C-compiler that is used for the build. (e.g. 
{\tt win32/microsoft/msvc60} for the microsoft visual c++ 6.0 compiler).
\end{description}
\end{description}

Any irrelevant variables (such as {\tt MATLABDIR} if {\tt MAKEFOR=SCILAB})
are ignored.

\subsubsection{Building \sca}
After setting the
`{\tt EPICS\_HOST\_ARCH}' (for EPICS 3.14) and `{\tt HOST\_ARCH}' (EPICS 3.13)
environment variables, {\em GNU} make is invoked in the \sca{} top 
directory. Note that the compiler toolchain must be found in the system
{\tt PATH}\footnote{
Under \windoze, the {\em msvc} compiler features a {\tt .BAT} file for
setting up the necessary environment.
}.

\subsection{Using \sca{}}
\sca{} consists of a set of shared libraries which in turn reference
other shared libraries (most notably the channel access client libraries
from EPICS BASE). It is of {\em crucial importance} that the operating
system locates the correct versions at {\em run-time} (i.e. the same versions
\sca{} was {\em linked} against). Otherwise, the run-time linker/loader
could fail to load the required objects --- leaving the user (expecially
in \matlab) at the prompt with obscure error messages.

Under {\em linux} or {\em solaris}, the {\tt LD\_LIBRARY\_PATH} environment
variable or the {\tt ld.so.conf / ldconfig} facility are used to point
to the executable shared libraries.

Under \windoze{}, the {\tt PATH} environment variable must point to the
correct EPICS BASE and \sca{} DLLs.

Note that the paths to the correct EPICS BASE \sca{} shared libraries
must be set up {\em prior} to starting the \scilab{} or \matlab{} application.
It is usually not possible to change the system search
path from within an application.

Possible problems could occur because
\begin{itemize}
\item third party setup scripts modify {\tt LD\_LIBRARY\_PATH / PATH}.
\item your EPICS BASE was not built with shared libraries but shared libraries
of a different release are found somewhere.
\item a ``innocent-looking'' directory present in {\tt LD\_LIBRARY\_PATH}
before EPICS BASE actually contains shared libraries of an older release.
\item Note that the system search path is {\em not} identical with the
\matlab{} path --- changing the \matlab{} path (from withing \matlab)
has no influence on the system search path.
\end{itemize}

\subsubsection{Using \sca{} with \scilab}
Set up the shared library search path (as described above) and start
\scilab. Run the {\tt ezca.sce} script which was generated by the build process
({\tt <\sca-top>/bin/<system>/ezca.sce}) to load the \sca{} interface.
The script can be installed at any convenient location.

It is also possible to permanently link \sca{} to \scilab{}. Consult
the \scilab{} documentation for more information.

\subsubsection{Using \sca{} with \matlab}
Every entry point / {\tt ezcaXXX} routine is contained in a separate
shared object file under {\tt <\sca-top>/bin/<system>/} which must
be added to the \matlab{} search path. Note that this is in {\em addition}
to setting the system library search path which must be performed prior
to starting \matlab{} (see previous section).
\end{document}
