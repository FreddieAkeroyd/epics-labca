\documentclass{article}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{bookman}
\usepackage{color}
\usepackage{graphics}

\newcommand{\sca}{{\em labCA}}
\newcommand{\scilab}{{\em scilab}}
\newcommand{\matlab}{{\em matlab}}
\newcommand{\ezca}{{\em ezca}}
\newcommand{\com}[1]{{\tt #1}}
\newcommand{\NAN}{\mbox{NaN}}

\newcommand{\PVITEM}{
\item[pvs] Column vector (in matlab: $m\times 1$ cell matrix)
of $m$ strings.
}


\begin{document}
\section{Introduction}
The \sca{} package provides an interface to the
EPICS channel access client library which can be
integrated with the \scilab{} or \matlab{} applications.
Both, \scilab{} and \matlab{} feature an API for interfacing
to user binaries written in a programming language such
as C or Fortran. \sca{} properly wraps the essential
channel access routines and makes them accessible
from the \scilab%
\footnote{throughout this text, references to \scilab{}
usually mean \scilab{} or \matlab.}
command line.

\sca{} actually uses an extra layer, the \ezca{} library
which transparently manages and caches channel access 
connections. A modified version of \ezca{} comes with
\sca, adding thread-safety and hence EPICS 3.14 fitness.

\section{Supported EZCA Calls}
\sca{} implements an interface to almost all public
\ezca{} routines\footnote{%
the \matlab{} implementation may still lack some of the
more esoteric commands}. Note that the arguments and
return values do not exactly correspond to the respective
\ezca{} originals but have been adapted to make sense
in the  \scilab{} environment.

\subsection{Common Arguments and Return Values}
\subsubsection{PV Argument}
All \sca{} calls take a {\em PV} argument identifying
the EPICS process variables the user wants to connect to.
PVs are plain ASCII strings. \sca{} is capable of handling
multiple PVs in a single call; they are simply passed as a
column vector:
\begin{verbatim}
pvs = [ 'PVa'; 'b'; 'anotherone']
\end{verbatim}
Because \matlab{} doesn't allow the rows of
a string vector to be of different size, the \matlab{}
wrapper expects a {\em cell} array of strings:
\begin{verbatim}
pvs = { 'PVa'; 'b'; 'anotherone'}
\end{verbatim}

All channel access activities for the PVs
passed to a single \sca{} call are batched together and
completion of the batch is awaited before returning from
the \sca{} call. Consider the following example:%
\footnote{
In \matlab{}, the square brackets (``[]'') must be replaced
by curly braces (``\{\}'').}
\begin{verbatim}
ezcaPut( 'trigger', 1 ) \\
data=ezcaGet( ['sensor1' ; 'sens2'] );
\end{verbatim}
\begin{itemize}
%
\item It is guaranteed that writing the ``trigger''
completes (on the CA server) prior to reading the
sensors.%%
\footnote{If the remote sensors have finite
processing time, the subsequent CA read may still
get old data --- depending on the device support
etc.; this is beyond the scope of channel access, however.}
%
\item Reading the two sensors is done in ``parallel'' ---
the exact order is unspecified. After the command sequence
(successfully) completes, all the data are valid.
\end{itemize}

\subsubsection{Timestamp Format}
\label{tsformat}
Channel access timestamps are ``POSIX struct timespec''
compliant, i.e. they provide the number of nanoseconds
expired since 00:00:00 UTC, January 1, 1970. \sca{} 
translates the timestamps into {\em complex numbers}
with the seconds ({\tt tv\_sec} member) and nanoseconds
({\tt tv\_nsec}) in the real and imaginary parts, respectively.
This makes it easy to extract the seconds while still maintaining
full accuracy.

\subsection{List of all Supported Calls}
\subsubsection{ezcaGet}
\label{ezcaget}
\begin{verbatim}
[value, timestamp] = ezcaGet(pvs, nmax, type)}
\end{verbatim}
Read a number of $m$ PVs, which may be scalars or arrays of
different dimensions. The result is converted into a $m\times n$
matrix. The number of columns, $n$, is automatically assigned
to fit the largest array among the $m$ PVs. All values are
converted into double precision numbers. PVs with less than
$n$ elements have their excess elements in the result matrix
filled with \NAN.
\begin{description}
\PVITEM
%
%
\item[nmax] ({\em optional argument}) Maximum number of elements
(per PV) to retrieve (i.e. limit the number of columns of \com{value} to
{\em nmax}).
If set to 0 (default), all elements are fetched
and the number of columns, $n$, in the result matrix is set to the
maximum number of elements among all submitted PVs. This is useful
to limit the transfer time of very large waveforms (unfortunately,
CA is not capable to return only the valid elements (``NORD'') of
an array --- it will always ship {\em all} elements).
%
%
\item[type] ({\em optional argument}) A string describing the
data type to be used for the channel access data transfer. Note
that \sca{} always converts the data to ``double'' locally. It
can be desirable, however, to use a different data type for the
transfer because by default CA transfers are limited to $\approx 16$kB.
Legal values for \com{type}{} are \com{byte}, \com{short}, \com{long},
\com{float}, \com{double} or \com{native}. There should rarely
be a need for using anything other than \com{native}, the default,
which directs CA to use the same type for transfer as the data are
stored on the server.

On \matlab{}{}, however, the type \com{char}{} is also allowed which
results in \com{ezcaGet()}{} behaving like \com{ezcaGetString()}{}
(see \ref{getstring} below).

Note that while \com{native}{} might result in different types
being used for different PVs, it is currently not possible to
explicitely request different types for different PVs (i.e. the
\com{type}{} argument currently cannot be a column vector).
%
%
\item[value] The $m\times n$ result matrix. $n$ is automatically
assigned to accomodate the PV with most elements. If the \com{nmax}{}
argument is given and is nonzero but less than the automatically
determined $n$, then $n$ is clipped to \com{nmax}.

Excess elements of PVs with less than $n$ elements are filled with
\NAN{} values.

\sca{} checks the channel access severity of the retrieved PVs and
fills the rows of {\em INVALID} PVs with \NAN. In addition, warning
messages are printed to the console if a PV's alarm status exceeds
a configurable threshold (see \ref{swarnlevel}).
%
%
\item[timestamp] ({\em optional return value}) Returns a $m\times 1$
column vector of {\em complex} numbers holding the CA timestamps of
the requested PVs. The timestamps count the number of seconds (real part)
and fractional nanoseconds (imaginary part) elapsed since
00:00:00 UTC, January 1, 1970.
\end{description}

\subsubsection{ezcaGetString}
\label{getstring}
Retrieve a number of PVs as strings, i.e. let the CA server convert
them to strings (if the PVs are not native strings already) and transfer
them. This is especially useful to read ``enum''-type PVs.

Note that the \matlab{} implementation lacks this command. It is implemented
by giving a \com{char}{} type argument to \com{ezcaGet}.
\begin{verbatim}
[value, timestamp] = ezcaGetString(pvs, nmax)
\end{verbatim}
\begin{description}
\PVITEM
%
%
\item[nmax] ({\em optional argument})
See \com{ezcaGet}{} (\ref{ezcaget}) for a description of this parameter.
\item[value] a $m\times n$ (\matlab: {\em cell}-) matrix of strings. See \com{ezcaGet}{}
(\ref{ezcaget}) for more information.
\item[timestamp] ({\em optional return value})
See \com{ezcaGet}{} (\ref{ezcaget}) for a description of this return value.
\end{description}

\subsubsection{ezcaPut}
\label{ezcaput}
Write to a number of PVs which may be scalars or arrays of different
dimensions. It is possible to write the same value to a number of PVs.
\begin{verbatim}
ezcaPut(pvs, value, type)
\end{verbatim}
\begin{description}
\PVITEM
%
%
\item[value] $m\times n$ matrix or $1\times n$ row vector of values
to be written to the PVs. If there is only a single row in \com{value}{}
it is written to all $m$ PVs.

It is possible to write less than $n$ elements --- \sca{} scans all rows
for \NAN{} values and only transfers up to the last non-\NAN{} element in each
row.
%
%
\item[type] ({\em optional argument}) A string describing the
data type to be used for the channel access data transfer. Note
that \sca{} always converts the data from ``double'' locally. It
can be desirable, however, to use a different data type for the
transfer because by default CA transfers are limited to $\approx 16$kB.
Legal values for \com{type}{} are \com{byte}, \com{short}, \com{long},
\com{float}, \com{double} or \com{native}. There should rarely
be a need for using anything other than \com{native}, the default,
which directs CA to use the same type for transfer as the data are
stored on the server.

On \matlab{}{}, however, the type \com{char}{} is also allowed which
results in \com{ezcaPut()}{} behaving like \com{ezcaPutString()}{}
(see \ref{putstring} below).

Note that while \com{native}{} might result in different types
being used for different PVs, it is currently not possible to
explicitely request different types for different PVs (i.e. the
\com{type}{} argument currently cannot be a column vector).
%
\end{description}

\subsubsection{ezcaPutString}
\label{putstring}
Write a number of PVs as strings, i.e. let the CA server convert
them to their native data type (if the PVs are not native strings already).
This is especially useful to write ``enum''-type PVs.

Note that the \matlab{} implementation lacks this command. It is implemented
by giving a \com{char}{} type argument to \com{ezcaPut}.
\begin{verbatim}
ezcaPutString(pvs, value)
\end{verbatim}
\begin{description}
\PVITEM
%
%
\item[value] a $m\times n$ (\matlab: {\em cell}-) matrix of strings. See \com{ezcaPut}{}
(\ref{ezcaput}) for more information.
\end{description}


\subsubsection{ezcaGetNelem}
\begin{verbatim}
numberOfElements = ezcaGetNelem(pvs)
\end{verbatim}
Retrieve the element count of a number of PVs. Note that this is not
necessarily the number of {\em valid} elements (e.g. the actual number
of values read from a device into a waveform) but the maximum number
of elements a PV can hold.
\begin{description}
\PVITEM
%%
\item[numberOfElements] $m\times 1$ column vector of the PV's number
of elements (``array dimension'').
\end{description}

\subsubsection{ezcaGetControlLimits}
\begin{verbatim}
[lowLimit, hiLimit] = ezcaGetControlLimits(pvs)
\end{verbatim}
Retrieve the control limits associated with a number of PVs.
\begin{description}
\PVITEM
%%
\item[lowLimit] $m\times 1$ column vector of the PV's low control limit.
\item[hiLimit]  $m\times 1$ column vector of the PV's high control limit.
\end{description}


\subsubsection{ezcaGetGraphicLimits}
\begin{verbatim}
[lowLimit, hiLimit] = ezcaGetGraphicLimits(pvs)
\end{verbatim}
Retrieve the graphic limits associated with a number of PVs.
\begin{description}
\PVITEM
%%
\item[lowLimit] $m\times 1$ column vector of the PV's low graphic limit.
\item[hiLimit]  $m\times 1$ column vector of the PV's high graphic limit.
\end{description}


\subsubsection{ezcaGetStatus}
\begin{verbatim}
[severity, status, timestamp]  = ezcaGetStatus(pvs)
\end{verbatim}
Retrieve the alarm severity and status of a number of PVs along
with their timestamp.
\begin{description}
\PVITEM
%%
\item[severity] $m\times 1$ column vector of the alarm severities.
\item[status] $m\times 1$ column vector of the alarm status.
\item[timestamp] $m\times 1$ {\em complex} column vector holding the
PV timestamps (see \ref{tsformat} about the timestamp format).
\end{description}


\subsubsection{ezcaGetPrecision}
\begin{verbatim}
precision = ezcaGetPrecision(pvs)
\end{verbatim}
Retrieve the precision of a number of PVs.
\begin{description}
\PVITEM
%%
\item[precisiom] $m\times 1$ column vector of the PV's precision.
\end{description}

\subsubsection{ezcaGetUnits}
\begin{verbatim}
units = ezcaGetUnits(pvs)
\end{verbatim}
Retrieve the engineering units of a number of PVs.
\begin{description}
\PVITEM
%%
\item[units] $m\times 1$ column vector (on \matlab: cell matrix)
of strings holding the PV EGUs.
\end{description}

\subsubsection{ezcaGetRetryCount, ezcaSetRetryCount}
\begin{verbatim}
currentRetryCount = ezcaGetRetryCount()
ezcaSetRetryCount(newRetryCount)
\end{verbatim}
Retrieve / set the \ezca{} library retryCount parameter (consult the \ezca{}
documentation for more information).


\subsubsection{ezcaGetTimeout, ezcaSetTimeout}
\begin{verbatim}
currentTimeout = ezcaGetTimeout()
ezcaSetTimeout(newTimeout)
\end{verbatim}
Retrieve / set the \ezca{} library timeout parameter (consult the \ezca{}
documentation for more information).

\subsubsection{ezcaDebugOn, ezcaDebugOff}
\begin{verbatim}
ezcaDebugOn()
ezcaDebugOff()
\end{verbatim}
Switch the \ezca{} library's debugging facility on and off, respectively.

\subsubsection{ezcaSetSeverityWarnLevel}
\label{swarnlevel}
\begin{verbatim}
ezcaSetSeverityWarnLevel(newlevel)
\end{verbatim}
Set the warning threshold for \com{ezcaGet()} operations.
A warning message is printed when retrieving a PV with a severity bigger
or equal to the warning level. Supported values are $0..3$ (No alarm,
minor alarm, major alarm, invalid alarm). The initial/default value is 3.
\end{document}
